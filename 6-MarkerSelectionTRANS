#!/usr/bin/perl
use warnings;
use strict;
use List::Util 'shuffle';
use File::Basename;
use List::Util qw( min max );
use Getopt::Std;


&main;
exit;

sub main {
        &usage if (@ARGV<1);
        my $command = shift(@ARGV);
        my %fun = (markers=>\&markers, seq=>\&seq);
        die("Unknown command \"$command\"\n") if (!defined($fun{$command}));
        &{$fun{$command}};
      }

sub usage {
  die(qq/
Usage: 6-MarkerSelection <command> [<arguments>]\n

Command: 

markers:          Find orthologous transcripts across transcriptomes

seq:              Generate input files for probe design


Note: always run step 1 -markers- first and then run step 2 -seq-.

\n/);
}



sub seq {
  
  die(qq/
6-MarkerSelection seq [options] 

options:

-f       FILE    A file containing a list of makers that you would like 
                 to use for probe design (e.g. marker_final.txt)
-d       DIR     Path to the deritory of orthologous sequences (files generated by 
                 6-MarkerSelection markers: ABC.final2, DEF.final2...)

 
\n\n/) unless (@ARGV);
  
  my %opts = (d=>undef, f=>undef);
  getopts('d:f:', \%opts);
  
  my $dir;
  if ($opts{d} =~ m/\/$/ ){
    $dir = $opts{d}; 
  }
  else {
    $dir = $opts{d} . "/";
  }
  
  my $outDir = $dir . 'Probe_Design/';
  mkdir $outDir unless -e $outDir;
  
  my @seq = <$dir*.final2>;
  
  foreach (@seq) {
    my $id = $1 if basename ($_) =~ m/(\S+).final/;
    my $coor = $outDir . $id . '_target_input_coordinats.tsv';
    my $seqFile = $outDir . $id . '_exonic_targets.txt'; 
    probe ($opts{f}, $_, $coor, $seqFile); 
  }
  
  sub probe {
    my ($id, $file, $coordinates,$target) = @_;
    open (IN, "<", $file);
    my %seq;
    while (<IN>) {
      chomp (my $line = $_);
      if ($line =~ m/^>(\S+)_(\S+)_(\S+)_(\S+)/) {
	
	
	my $species = $1;
	my $contig = $2;
	my $prot = $3;
	my $gene = $4;
	chomp (my $seq = <IN>);
	$seq{$prot} = {'species' => $species, 'contig' =>$contig, 'seq'=>$seq, 'gene' =>$gene};  
      }
    }
    close IN;
    
    open (IN1, "<", $id);
    open (TAR, ">", $target);
    open (COR, ">", $coordinates);
    my $a = 1;
    my $total;
    while (<IN1>) {
      chomp ($_);
      if ($_ =~ m/^(ENS\S+)/) {
	my $d = $1;	
	if ($seq{$d}) {
	  my $len = length ($seq{$d}{'seq'});
          $total += $len;
	  print TAR ">", "chr_", $seq{$d}{'species'}, "_", $seq{$d}{'contig'}, "_", $d, "_",$seq{$d}{'gene'} , "\n";
	  print TAR $seq{$d}{'seq'}, "\n";	
	  print COR $a, "\t", "chr_", $seq{$d}{'species'}, "_", $seq{$d}{'contig'}, "_", $d , "_",$seq{$d}{'gene'} ,"\t", "1", "\t", $len, "\n";
	  $a++;
	}	
      }
    }
    print "The target size for ", basename($file), " is ", $total, "bp!", "\n";
    close IN1; 
    close TAR;
    close COR;
    
  }
}


sub markers {
die(qq/
6-MarkerSelection markers [<arguments>]\n

external dependencies: blastn

options:
-f    FILE      The path to all the annotated fasta files 
                (naming of the file has to be [A-Z|a-z|0-9].fasta)
-i    INT       Minimal length cutoff (bp) for a transcript to keep [200]
-a    INT       Only keep the leading a (bp) if the length of the 
                transcript is longer than a (bp) [2000]
-M    FLOAT     Maximun GC content cutoff for an exon to keep [0.7]
-m    FLOAT     Minimal GC content cutoff for an exon to keep [0.4]

NOTE: a must be greater than i

\n\n/) unless (@ARGV);

my %opts = (f=>undef,  i=>200, a=>2000, M=>0.7, m=>0.4, n=>1);
getopts('f:i:a:m:M:n:', \%opts);
#######################################################
#-n    INT       How many random exons do you want to use as popgen markers [2000]
#my $popGen = $opts{n} if ($opts{n}) ;
my $popGen = 1;
#######################################################

my $dir;
if ($opts{f} =~ m/\/$/ ){
$dir = $opts{f}; 
}
else {
$dir = $opts{f} . "/";
}


my $exonLength = $opts{i};
my $Max_exonLength = $opts{a} ;
my $minGC = $opts{m} if ($opts{m});
my $maxGC = $opts{M} if ($opts{M}) ;


my @annotation = <$dir*.fasta>;

my @other_annotation;
my $master;
my $dc =1;
foreach (@annotation) {
$master = $_ if $dc == 1;
push @other_annotation, $_ if $dc > 1;
$dc ++;
}



my $resdir = $dir . "results/";
mkdir $resdir unless -e $resdir;

my $master1 = $resdir . basename($opts{f}) . "1";
re_name ($master, $master1);


my $d = 2;

#unless ($resdir . basename($opts{f}) . "final" ) {
  foreach (@other_annotation) {
    my $lib = $resdir . basename($_) . "1";
    re_name ($_, $lib);
    my $new_master = $resdir . basename($master) . $d;
    blast1 ($resdir, $master1, $lib, $exonLength, $Max_exonLength, $new_master);
    $d++;

    system ("rm $master1");

    $master1 = $new_master ;
  }
  
  my $final_marker = $resdir . basename($master) . "1_".$d;
  self ($master1, $final_marker, $resdir);
  system ("rm $master1");
  
  
  my @final = <$resdir*fasta1>;
  foreach (@final) {  
    my $out = $_ . "_". $d;
    marker($resdir, $_, $final_marker, $out, $exonLength);  
  }
  system ("rm $resdir*fasta1");
  
  my @files = <$resdir*_$d>;
  foreach (@files) {
    my $lib = $1 if $_ =~ m/(\S+)\./;
    my $out = $lib . ".final";
    my $lid = $1 if basename($_) =~ m/(\S+)\./;
    open (IN, "<", $_);
    open (OUT, ">", $out);
    while (<IN>) {
      chomp (my $line = $_);
      if ($line =~ m /^>(\S+)/) {
	chomp ( my $seq =<IN>);
	print OUT ">", $lid, "_", $1, "\n";
	print OUT $seq, "\n";	
      }
    }
    close IN; close OUT;  
  }
  system ("rm $resdir*_$d");
#}

find_homologs($resdir,$Max_exonLength, $exonLength);
calculateDiv ($resdir, $exonLength);
filter($resdir, $Max_exonLength, $exonLength,$minGC, $maxGC, $popGen);

################################################################################################

sub filter {
  my ($dir, $Max_exonLength, $exonLength,$minGC,$maxGC,$popGen ) = @_;
  my $in = $dir . "marker_summary.txt";
  open (IN, "<", $in);
  my $out1 = $dir . "marker_kept.txt";
  open (OUT1, ">", $out1);
  my $out2 = $dir . "marker_abandoned.txt";
  open (OUT2, ">", $out2);
  
  chomp (my $first = <IN>); 
  print OUT1 $first, "\n";
  print OUT2 $first, "\n";
  
  while (<IN>) {
    chomp (my @line = split /\t/, $_);
    if ($line[3] >= $exonLength && $line[4] >= $minGC && $line[4] <= $maxGC) {
      print OUT1 join ("\t", @line), "\n";
    }
    else {
      print OUT2 join ("\t", @line), "\n";
      
    }
  }	
  
  close IN;
  close OUT1;
  close OUT2;
   
  my $out4 = $dir . "random_popgen_markers.txt1";
  open (IN, "<", $out1);
  open (OUT, ">", $out4);
  my @array2;
  while (<IN>) { 
    chomp (my $line = $_);
    if ($line =~ m /ENS\S+/) {
      push @array2, $line;
    }
  }
  close IN;
  print OUT $first, "\n";
  my @s = shuffle(0..$#array2);
  if (scalar (@array2) >= $popGen) {
    my @p = @s[ 0 .. $popGen - 1];
    foreach (@p) {
      print OUT $array2[$_], "\n";
    }
  }
  else {
  print "You only have ", scalar (@array2), " useful transcripts! ", "Please reset -n and rerun the script! ", "\n"; 
  exit;
  }
  
  
  close OUT;
  
  my $marker_final = $dir . "random_popgen_markers.txt";
  system ("sort -k 2n,2 -k 4n,4 $out4 > $marker_final "); 
  system ("rm $out4");
  
  
  my $marker1 = $dir . "marker_kept_sorted.txt";
  system ("sort -k 2n,2 -k 4n,4 $out1 > $marker1 "); 
  system ("mv $marker1 $out1");
  
}


sub calculateDiv {
  my ($dir, $exonLength) = @_;
  my $out = $dir . "marker_summary.txt";
  my @aln = <$dir*.aln>;
  my @seq = <$dir*.final2>;
  
  open(OUT, ">", $out);
  
  print OUT "Transcript_name", "\t", "avgDiv", "\t"," varianceDiv", "\t", "avgLength", "\t", "avgGC", "\t";
  
  for (my $i = 0; $i < scalar @seq; $i++) {
    for (my $j = $i+1; $j < scalar @seq; $j++) {	
      my $sp1 = $1 if  basename($seq[$i]) =~ m/(\S+).final/;
      my $sp2 = $1 if  basename($seq[$j]) =~ m/(\S+).final/;
      
      print OUT "div_",$sp1, "_vs_", $sp2, "\t";
    }
  }
  print OUT "\n";
  
  foreach my $aln (@aln) {
    
    open(IN, "<$aln");
    my $gene = $1 if basename($aln) =~ m/(\S+).aln/;
    
    my %ind;  
    my $id; 
    my $species; 
    my $contig; 
    my $exon;
    my $gen;
 
    while (<IN>) {
      chomp (my $line = $_); 
      if ($line =~ m/^>(\S+)\s+/) {
	$species = $1;
	my @d =split /\s+/, $line;
	$contig = $d[1];
	$exon = $d[2]; 
	$gen = $d[3];
	$ind{$species} = {'contig' => $contig, 'exon' => $exon, 'gene' => $gen};		    
      }
      else {
	$ind{$species}{'seq'} .= uc ($line); 
	my $seq1 = $line;
        my $N1 =  ($seq1 =~ s/-//g);
$ind{$species}{'N'} += length ($N1);
      }
    }
    close IN; 
    system ("rm $aln");
    
 


    my %sequence;		
    foreach my $inds (sort {$a cmp $b} keys %ind) {

      push (@{$sequence{'h'}},  {'species' =>$inds, 'gene' => $ind{$inds}{'gene'},   'contig' => $ind{$inds}{'contig'}, 'exon' => $ind{$inds}{'exon'}, 'seq' => $ind{$inds}{'seq'}});
    }
    print OUT $gene, "\t";
    
    my @div;	
    my $zero = 0;
    for (my $i = 0; $i < scalar (@{$sequence{'h'}}); $i++) {
      for (my $j = $i+1; $j < scalar (@{$sequence{'h'}}); $j++) {	
	my $div = div($sequence{'h'}[$i]{'seq'}, $sequence{'h'}[$j]{'seq'});
	$div = sprintf("%.4f",$div) unless ($div eq 'NA');
	unless ($div eq 'NA') {
	  $zero++ if $div == 0;
	}
	push(@div,$div);
      }
    }		
    
    
    my @length; my @gc; my $length = 0;
    foreach my $c (sort {$a cmp $b} keys %ind) {
      my $seq = $ind{$c}{'seq'};
      my $l = ($seq =~ s/[atgc]//ig);
      $seq = $ind{$c}{'seq'};
      my $gc = ($seq =~ s/[gc]//ig);
      $length++ if $l < $exonLength;
      push(@length,$l);
      push(@gc,$gc);
    }
    
    
    
    my $avgDiv = sprintf("%.4f",average(\@div));
    print OUT $avgDiv, "\t";
    my $var = sprintf("%.4f",variance($avgDiv,\@div));
    print OUT $var, "\t";	  
    my $avgLength = sprintf("%d",average(\@length));
    print OUT $avgLength, "\t";	  
    my $avgGC = sprintf("%.4f",average(\@gc)/$avgLength);
    print OUT $avgGC, "\t";
    print OUT join ("\t", @div);
    print OUT "\n";
    
  }
  close(OUT);
  
}


sub variance {
  my ($avg, $a) = @_;
  my @a = @{$a};
  my $var;
  if (scalar(@a) > 0) {
    my $sum = 0; my $num;
    foreach my $var (@a) {
      unless ($var eq 'NA') {
	$sum += ($avg - $var) ** 2;
	$num++;
      }
    }	
    $var = $sum/$num;
  }
  else {
    $var = 0;
  }
  return($var);
}		

sub average {
  my ($a) = @_;
  my @a = @{$a};
  my $avg;
  if (scalar(@a) > 0) {
    my $sum = 0; my $num;
    foreach my $var (@a) {
      unless ($var eq 'NA') {
	$sum += $var;
	$num++;
      }
    }	
    $avg = $sum/$num;
  }
  else {
    $avg = 0;
  }
  return($avg);
}

sub div {	
  my ($seq1,$seq2) = @_;
  my @b1 = split(//,$seq1);
  my @b2 = split(//,$seq2);
  
  my %ti = ('A' => 'G', 'G' => 'A', 'C' => 'T', 'T' => 'C');
  
  my $gc; 
  #my $ti = 0; 
  my $tv = 0; 
  my $l =0;;
  
   for (my $j = 0; $j < scalar(@b1); $j++) {
    if (uc($b1[$j]) =~ m/[A|T|G|C|]/i) {
      if (uc($b2[$j]) =~ m/[A|T|G|C]/) {	
	$l++;
	if (uc($b1[$j]) ne uc($b2[$j])) {	
	  $tv++;
	}
      }	
    }
  }

  #for (my $j = 0; $j < scalar(@b1); $j++) {
  #  if (uc($b1[$j]) =~ m/[A|T|G|C]/i) {
  #    if (uc($b1[$j]) =~ m/[G|C]/i) {
  #	$gc++;
  #    }	
   #   if (uc($b2[$j]) =~ m/[A|T|G|C]/) {	
#	$l++;
#	if (uc($b1[$j]) ne uc($b2[$j])) {
#	  if ( $ti{uc($b1[$j])} eq uc($b2[$j]) ) {
#	    $ti++;
#	  }
#	  else {	
#	    $tv++;
#	  }
#	}	
  #   }	
  #  }
 # }
  
  my $div;
  $div = $tv/$l if $l > 0;
  $div = "NA" if $l == 0;
  	
  #if ($l > 0) {	
   # my $p = $ti/$l; my $q = $tv/$l; my $w = $gc/$l;
    
  #  if ($w == 1) {
  #    $div = 'NA';
  #  }
  #  else {	
  #    my $a = 1 - ( $p/ (2 * $w * (1 - $w) ) ) - $q;
  #    my $b = 1 - 2 * $q ;
  #    if ($a <= 0 || $b <= 0 ) {
  #	$div = 'NA';
  #    }
  #    else {	
#	$div = (-2*$w) * ( 1 - $w) *  log( $a ) - 0.5 * ( 1 - 2 * $w * ( 1 - $w ) ) * log($b);
 #     }
  #  }	
  #}
  #else {
  #  $div = 'NA';
  #}


  return($div);
}



sub find_homologs {
  my ($dir, $max, $min) = @_;
  my @seq = <$dir*final>;
  foreach (@seq) {
    my $file = $_;
    my $lib = $1 if (basename ($file) =~ m/(\S+)\.final/);
    my $out = $dir . $lib . ".final2";
    open (IN, "<", $file);
    open (OUT, ">", $out);
    
    while (<IN>) {
      chomp (my $line = $_);
      if ($line =~ m /^>/) {
	
	chomp (my $seq = <IN>);
	if (length ($seq) >= $min && length ($seq) <= $max) {
	  print OUT $line ,"\n";
	  print OUT $seq, "\n";
	}
	if (length ($seq) > $max) {
	  print OUT $line ,"\n";
	  print OUT substr ($seq, 0, $max), "\n";
	}
      }
    }
    close IN;
    close OUT;
  }
  system ("rm $dir*final");
  my @seq2 = <$dir*final2>;
  my $total = scalar (@seq2);
  my $combined = $dir . 'combined_transcripts.fa'; 
  system ("cat $dir*final2 > $combined ");
  
  my %seq;
  
  my $muscle = 'muscle';

  my $out1 = $combined. "_1";
  open (IN, "<", $combined);
  open (OUT, ">", $out1);	
  while (<IN>) {
    chomp (my $line = $_); 
    if ($line =~ m/>(\S+)_(\S+)_(\S+)_(\S+)/) {
      my $species = $1;
      my $contig = $2;
      my $exon = $3;
      my $gene = $4;
      chomp (my $seq = <IN>);
      print OUT $species, "\t", $contig, "\t", $exon, "\t",  $gene, "\t", $seq, "\n";    
    }
  }
  close IN; close OUT; 
  system ("rm $combined ");
  my $out2 = $combined. "_sorted";	
  system ("sort -k 3,3 -k 1,1 $out1 > $out2");
  system ("rm $out1");
  
  open (IN1, "<",  $out2);
  while (<IN1>) {
    chomp(my $line = $_);
    my @d = split(/\t/,$line);
    if ($seq{$d[2]}{'hulala'}) {		
      push @{$seq{$d[2]}{'hulala'}}, {'contig' => $d[1], 'species' => $d[0], 'gene'=> $d[3], 'seq' => $d[4]};		
    }
    else { 
      push @{$seq{$d[2]}{'hulala'}}, {'contig' => $d[1], 'species' => $d[0], 'gene'=> $d[3], 'seq' => $d[4]};	
    }
  }											
  close IN1;
  system ("rm $out2");
  
  
  foreach my $id (keys %seq) {
    if (scalar (@{$seq{$id}{'hulala'}}) == $total) {
      my $in_muscle = $dir . $id . '.in';
      open (OUT, ">", $in_muscle);
      for (my $t = 0; $t < $total; $t++) {
	print OUT ">", $seq{$id}{'hulala'}[$t]{'species'}, "\t", $seq{$id}{'hulala'}[$t]{'contig'}, "\t", $id, "\t", $seq{$id}{'hulala'}[$t]{'gene'}, "\n", $seq{$id}{'hulala'}[$t]{'seq'},"\n";
      }
      close OUT;
      my $out_muscle = $dir . $id . ".aln";
      
      my $call1 = system("muscle -quiet -in $in_muscle -out $out_muscle");
      my $call2 = system("rm $in_muscle") if (-f $out_muscle);
    }
  }
}


sub seqhash {
  my ($file) = @_;
  my %seq;
  open (IN, "<", $file); 
  while (<IN>) {
    chomp (my $line = $_);
    if ($line =~ m /^>(\S+)/) {    
      chomp (my $s = <IN>);
      $seq{$1} ={'seq'=>$s, 'len'=> length ($s)};  
    }   
  }
  close IN;
  return (\%seq);
}

 
sub self {
    my ($new_master, $final_marker, $resdir) = @_;
    my $new_master1 = $new_master . "_copy";
    system ("cp $new_master $new_master1" );
    my $blastout = $resdir . 'blast.out';
    my $call1 = system("makeblastdb -in $new_master -dbtype nucl");
    my $call2 = system("blastn -db $new_master -query $new_master1 -evalue 1e-20 -outfmt 6 -out $blastout");
    system("rm $new_master.n* $new_master1 ");
       
    my $hash = seqhash($new_master);
    
    my %seq = %{$hash};
    my %final= %{$hash};
    
    my %tmp;
    open(IN, "<$blastout");
    while (<IN>) {
      chomp(my $line = $_);
      my @d = split(/\s+/,$line);
      push(@{$tmp{$d[0]}},\@d);
    }
    close(IN);
    system ("rm $blastout");
      
    my %final1;
    foreach my $id (sort {$a cmp $b} keys %tmp) {
      my %match;
      if (scalar(@{$tmp{$id}}) > 1) {
      for (my $i = 0; $i < scalar(@{$tmp{$id}}); $i++) {   
	  $match{$tmp{$id}[$i][1]} = $seq{$tmp{$id}[$i][1]}{'len'};      	  
      }
       
      foreach my $ids (sort { $match{$b} <=> $match{$a} } keys %match) {
	    $final1{$ids}{'seq'} = $final{$ids}{'seq'};
	    $final1{$ids}{'len'} = $final{$ids}{'len'};
	    last; 
       }
    
    }
	      
    if (scalar(@{$tmp{$id}} == 1) ) {
       $final1{$id}{'seq'} = $final{$id}{'seq'};
       $final1{$id}{'len'} = $final{$id}{'len'};
    }  

   }
    my $ref = $resdir. "tmp_file.txt";
    open (OUT, ">", $ref);
    foreach my $anno (sort {$a cmp $b} keys %final1) {
	  print OUT  ">", $anno, "\n", $final1{$anno}{'seq'}, "\n";     
	}   
       close OUT;
    

    my $ref1 = $ref . ".1"; 
    system("cd-hit-est -i $ref -o $ref1 -M 0 -l 36 -d 100 -B 1 -r 1 -n 8");
    system ("mv $ref1 $final_marker");
    system ("rm $ref1.* $ref");

  }


sub marker {
  my ($dir, $file, $final, $out, $min) = @_;
  my $blastout = $dir. basename ($final) . "_" . basename ($file). "_". 'Blast.out';
  my $call1 = system("makeblastdb -in $file -dbtype nucl");
  my $call2 = system("blastn -db $file -query $final -out $blastout -evalue 1e-20 -outfmt 6");
  system ("rm $file.n* ");
  
  
  my $hash = seqhash ($file);
  my %seq = %{$hash};
  
  my %r;
  open(IN, "<", $blastout);
  while(<IN>) {
    chomp(my $line = $_);
    my @d = split(/\s+/,$line);
    next if ( $d[3] < $min);   
    my $gene0 = $1 if $d[0] =~ m /\S+_\S+_(\S+)/;
    my $gene1 = $1 if $d[1] =~ m /\S+_\S+_(\S+)/;
    next if ( $gene0 ne $gene1);    
    unless ($r{$d[0]}) {
      $r{$d[0]} = {'gene' => $d[1], 'start' => $d[8], 'end' => $d[9], 'mis' => $d[2]};
    }
  }  
  close(IN);
  unlink ($blastout);
  open (NEW, ">", $out);
  foreach my $id (sort {$a cmp $b} keys %r) {
    if ($seq{$r{$id}{'gene'}}) {
      if (($r{$id}{'end'}) > ($r{$id}{'start'})) { 
	print NEW ">",$r{$id}{'gene'}, "\n";
	print NEW substr ($seq{$r{$id}{'gene'}}{'seq'},$r{$id}{'start'}-1, $r{$id}{'end'}-$r{$id}{'start'}+1), "\n";
      }
      if (($r{$id}{'end'}) < ($r{$id}{'start'})) {
	my $start = $r{$id}{'end'};
	my $end = $r{$id}{'start'};
	my $sequence = substr ($seq{$r{$id}{'gene'}}{'seq'},$start-1, $end-$start+1);
	$sequence = reverse($sequence);
	$sequence =~ tr/ATGCatgc/TACGtacg/;
	print NEW ">",$r{$id}{'gene'}, "\n";
	print NEW $sequence, "\n";	
      }
      
    }
  }
  close NEW; 
}

sub blast1 {
  my ($dir, $master, $file1, $min, $max, $out) = @_;
  my $blastout = $dir. basename ($master) . "_" . basename ($file1). "_". 'Blast.out';
  my $call1 = system("makeblastdb -in $file1 -dbtype nucl");
  my $call2 = system("blastn -db $file1 -query $master -out $blastout -evalue 1e-20 -outfmt 6");
  system ("rm $file1.n* ");
  open(IN, "<", $blastout);
  my %r;
  while(<IN>) {
    chomp(my $line = $_);
    my @d = split(/\s+/,$line);
    
    my $gene0 = $1 if $d[0] =~ m /\S+_(\S+)_\S+/;
    my $gene1 = $1 if $d[1] =~ m /\S+_(\S+)_\S+/;
    next if ( $gene0 ne $gene1);
    
    unless ($r{$d[0]}) {
      #if ($d[3] > $max) { #301
#	$r{$d[0]} = {'start' => $d[6], 'end' => $d[6]+$max-1};	
      #}
      #elsif ( $d[3] >= $min && $d[3] <= $max) {
	#$r{$d[0]} = {'start' => $d[6], 'end' => $d[7]};	
      #}
      #elsif ( $d[3] < $min){
#	next;
 #     }
	if ( $d[3] >= $min) {
	  $r{$d[0]} = {'start' => $d[6], 'end' => $d[7]};	
	}
      }  
  }
  close(IN);
  unlink ($blastout);
  
  open (MASTER, "<", $master); 
  my %seq;
  while (<MASTER>) {
    chomp (my $line = $_);
    if ($line =~ m /^>(\S+)/) {  
      chomp (my $s = <MASTER>);
      $seq {$1} = $s;
    }   
  }
  close MASTER;
  open (NEW, ">", $out);
  foreach my $id (sort {$a cmp $b} keys %r) {
    if ($seq{$id}) {
      print NEW ">", $id, "\n";
      print NEW substr ($seq{$id},$r{$id}{'start'}-1, $r{$id}{'end'}-$r{$id}{'start'}+1), "\n";
    }     
  }
  close NEW;
}


sub re_name {
  my ($in, $out) = @_;
  open (IN, "<", $in); 
  open (OUT,">", $out);
  while (<IN>) {
    chomp (my $line =$_);
    if ($line =~ m/^>\S+/) {
      my @d = (split /\s+/, $line);
      if ($d[1]) {
	chomp (my $seq = <IN>);	
	print OUT $d[0]."_".$d[2]."_".uc($d[3]),"\n" ;
	print OUT $seq, "\n";   
      }
    } 
  } 
  close IN; close OUT;
}

}

